---
title: "dcdm_clean_sama"
format: html
editor: visual
---


```{r}
# Load required libraries
library(tidyverse)
library(dplyr)
library(stringr)
```

```{r}
# Load required libraries
library(tidyverse)
library(dplyr)
library(stringr)

# Define the working directory path in R
rootDir = "/Users/sama/Desktop/DCDM_proj2/"

# Define file paths
file_path <- "/Users/sama/Desktop/DCDM_proj2/data/metadata/IMPC_parameter_description.txt"

# Read in the raw data lines
raw_lines <- readLines(file_path)
```


```{r}
# Function to identify issues
identify_issues <- function(lines) {
  issue_report <- data.frame(
    line_number = integer(0),
    issue_type = character(0),
    problematic_content = character(0),
    stringsAsFactors = FALSE
  )
  
  for (i in 1:length(lines)) {
    line <- lines[i]
    
    # Check for missing commas between column names
    if (str_count(line, ",") < 4) {
      issue_report <- rbind(issue_report, data.frame(
        line_number = i,
        issue_type = "Missing Comma",
        problematic_content = line
      ))
    }
    
    # Check for extra commas inside parentheses (commas inside parentheses should be preserved)
    if (grepl("\\(.*\\)", line) && str_count(line, ",") > 1) {
      issue_report <- rbind(issue_report, data.frame(
        line_number = i,
        issue_type = "Extra Comma Inside Parentheses",
        problematic_content = line
      ))
    }
  }
  
  return(issue_report)
}

# Call the function to identify issues in the dataset
issue_report <- identify_issues(raw_lines)

# Output the issue report in R console
print(issue_report)

```



```{r}
# Define the working directory path in r
rootDir = "/Users/sama/Desktop/DCDM_proj2/"

# SOP Reading
SOP <- read.csv(paste0(rootDir, "data/metadata/IMPC_sop.csv"))

# Define file paths
file_path <- "/Users/sama/Desktop/DCDM_proj2/data/metadata/IMPC_parameter_description.txt"

raw_lines <- readLines(file_path)

raw_lines <- raw_lines[-1]

# Remove leading and trailing quotes from each line
raw_lines <- gsub('^"|"$', '', raw_lines)

# Remove remaining embedded quotes
raw_lines <- gsub('"', '', raw_lines)

raw_lines <- gsub("^(\\S+)\\s+(\\S+)", "\\1,\\2", raw_lines)

# Replace commas inside parentheses with a placeholder (__COMMA__)
raw_lines <- str_replace_all(raw_lines, "(\\([^)]*\\))", function(x) str_replace_all(x, ",", "__COMMA__"))

# Replace commas inside quotes with a placeholder (__COMMA__)
raw_lines <- str_replace_all(raw_lines, "\"([^\"]*)\"", function(x) str_replace_all(x, ",", "__COMMA__"))

# Inspect the updated raw_lines
head(raw_lines)

# Split the lines by commas
split_lines <- str_split(raw_lines, ",", simplify = TRUE)

for (i in 1:nrow(split_lines)) {
  # Replace __COMMA__ with commas in name and description columns
  split_lines[i, 3] <- str_replace_all(split_lines[i, 3], "__COMMA__", ",")  # 3rd column = name
  split_lines[i, 4] <- str_replace_all(split_lines[i, 4], "__COMMA__", ",")  # 4th column = description
}

# Convert the split lines into a data frame
df <- as.data.frame(split_lines, stringsAsFactors = FALSE)


# Split the lines by commas
split_lines <- str_split(raw_lines, ",", simplify = TRUE)

# Inspect the split data
head(df)


```
```{r}
# Step 1: Make the first row the column names
colnames(df) <- df[1, ]
df <- df[-1, ]
rownames(df) <- NULL
```


```{r}
colnames(df)
```


```{r}

# Step 1: Clean column names by removing leading/trailing spaces
colnames(df) <- trimws(colnames(df))

# Step 2: Remove empty columns
df <- df[, colnames(df) != ""]  # Remove columns with empty names

# Step 3: Rename columns to match your desired names
df <- df %>%
  rename(
    line_number = line_number,
    IMPC_parameter_orig_id = impcParameterOrigId,
    parameter_name = name,
    description = description,
    parameter_id = parameterId
  )

# Inspect the updated dataframe
head(df)

```
```{r}
# Function to validate values based on the SOP type ("String" or "Float")
validate_type_minmax <- function(x, dataType, min_val, max_val) {
  if (tolower(dataType) == "string") {
    which(sapply(x, nchar) < min_val | sapply(x, nchar) > max_val)
  } else if (tolower(dataType) == "float") {
    which(as.numeric(x) < min_val | as.numeric(x) > max_val)
  } 
}

# Check if values in a list are within the allowed values of a given vector
check_allowed_values <- function(values, allowed_values) {
  which(!values %in% allowed_values) # Find indices of invalid values
}

# Function to combine multiple lists of indices and return unique indices
combine_unique_indices <- function(...) {
  sort(unique(unlist(list(...))))
}

# Function to print the indices and values where issues were identified
print_invalid_indices_and_values <- function(x, variable_name, invalid_indices) {
  # Count the number of issues
  num_issues <- length(invalid_indices)
  
  # Print the contextual message
  cat("The '", variable_name, "' column has ", num_issues, " issue(s).\n", sep = "")
  
  # Print indices and values if there are any issues
  if (num_issues > 0) {
    cat("Indices:\n")
    print(invalid_indices)
    cat("Values:\n")
    print(x[invalid_indices])
  }
}

# Extract field names from the data table (df)
field_names <- colnames(df)
print(field_names)

# Loop through each field name to apply SOP checks
for (field_name in field_names) {
  cat("Processing field:", field_name, "\n")
  
  # Extract the corresponding row in the SOP for each field
  sop_row <- SOP[SOP$dataField == field_name, ]
  
  if (nrow(sop_row) == 0) {
    next  # Skip if no SOP rule exists for the field
  }

# Access the column by name from the df
  column <- df[[field_name]]
  
  # Validate the column based on SOP constraints (Type, Min, Max)
  SOP_constraints <- validate_type_minmax(column, sop_row$dataType, sop_row$minValue, sop_row$maxValue)
  
  # Initialize a variable for field-specific checks
  field_specific_check <- integer(0)  # Default to an empty vector
  
  # Combine all indices of invalid values from SOP and field-specific checks
  invalid_indices <- combine_unique_indices(SOP_constraints, field_specific_check)
  
  # Print the invalid indices and their corresponding values (if any issues)
  print_invalid_indices_and_values(column, field_name, invalid_indices)
}


```


