---
title: "Sama_Cleaning"
format: html
editor: visual
---

```{r}
# Load required libraries
library(tidyverse)
library(dplyr)
library(stringr)
```

Define all the pathways; directory, SOP and the metadata to be cleaned. SOPs provide standardized descriptions and guidelines for parameters, measurements, or methodologies.

```{r}
# Define the working directory path in r
rootDir = "/Users/sama/Desktop/DCDM_proj2/"

# SOP Reading
SOP <- read.csv(paste0(rootDir, "data/metadata/IMPC_sop.csv"))

# Define file path
file_path <- "/Users/sama/Desktop/DCDM_proj2/data/metadata/IMPC_parameter_description.txt"

# Read the metadata file (assuming tab-delimited, change delimiter if needed)
metadata <- read_delim(file_path, delim = ",")

metadata
```

Initital observation:

The metadata contains five columns; line_number, impcParameterOrigId, name, description, parameterId.

-   The entire metadata is being read as a single column where all the rows are stored as strings.
-   They all are under a label 'x'. First two columns are merged as one and is not separated by comma.
-   There may be a redundancy between name and description, as they often describe the same parameter but in different styles.
-   They are all presented as characters, although some columns contains numeric values.

```{r}

# Use gsub() to replace the space in the first column with a comma, separating the merged values
metadata$x <- gsub("^(\\S+)\\s+(\\S+)", "\\1,\\2", metadata$x)

```

gsub() fixes improperly merged columns by replacing the first space in each row with a comma. This prepares the data for separation into multiple columns.

-   \^(\\S+)\\s+(\\S+): Captures two groups of non-whitespace characters separated by whitespace.

-   \\1,\\2: Replaces the whitespace between them with a comma.

```{r}
# Separate 'x', the single column into multiple columns.
metadata <- metadata %>%
  separate(x, into = c("line_number", "impcParameterOrigId", "name", "description", "parameterId"), sep = ",", extra = "merge", fill = "right")

# Remove the first row as it's been used for column names.
metadata <- metadata %>% slice(-1)

# Renaming columns in the metadata dataframe to match the SOP. 
metadata <- metadata %>%
  rename(
    line_number = line_number,
    IMPC_parameter_orig_id = impcParameterOrigId,
    parameter_name = name,
    description = description,
    parameter_id = parameterId
  )
```

Using separate(), it will split the single 'x' column into different columns based on commas.

-   extra = "merge": If there are more fields than columns, merge the extra fields into the last column.
-   fill = "right": Adds NA to empty columns when there are fewer fields than columns.

Each columns are then renamed to correspond to SOP.

```{r}
# Convert the first two columns to integers
metadata <- metadata %>%
  mutate(
    line_number = as.numeric(line_number),
    IMPC_parameter_orig_id = as.numeric(IMPC_parameter_orig_id)
  )

str(metadata)
```

This script validates columns in a metadata table against constraints defined in an SOP. It then retrieves the column names from the metadata table and prints them for reference and loops through each field name in order to check against the SOP. Furthermore, it skips columns with no SOP definition.

```{r}
# Function to validate values based on the SOP type ("String" or "Float")
validate_type_minmax <- function(x, dataType, min_val, max_val) {
  if (tolower(dataType) == "string") {
    which(sapply(x, nchar) < min_val | sapply(x, nchar) > max_val)
  } else if (tolower(dataType) == "float") {
    which(as.numeric(x) < min_val | as.numeric(x) > max_val)
  } 
}

# Check if values in a list are within the allowed values of a given vector
check_allowed_values <- function(values, allowed_values) {
  which(!values %in% allowed_values) # Find indices of invalid values
}

# Function to combine multiple lists of indices and return unique indices
combine_unique_indices <- function(...) {
  sort(unique(unlist(list(...))))
}

# Function to print the indices and values where issues were identified
print_invalid_indices_and_values <- function(x, variable_name, invalid_indices) {
  # Count the number of issues
  num_issues <- length(invalid_indices)
  
  # Print the contextual message
  cat("The '", variable_name, "' column has ", num_issues, " issue(s).\n", sep = "")
  
  # Print indices and values if there are any issues
  if (num_issues > 0) {
    cat("Indices:\n")
    print(invalid_indices)
    cat("Values:\n")
    print(x[invalid_indices])
  }
}

# Extract field names from the data table (metadata)
field_names <- colnames(metadata)
print(field_names)

# Loop through each field name to apply SOP checks
for (field_name in field_names) {
  cat("Processing field:", field_name, "\n")
  
  # Extract the corresponding row in the SOP for each field
  sop_row <- SOP[SOP$dataField == field_name, ]
  
  if (nrow(sop_row) == 0) {
    next  # Skip if no SOP rule exists for the field
  }

# Access the column by name from the metadata
  column <- metadata[[field_name]]
  
  # Validate the column based on SOP constraints (Type, Min, Max)
  SOP_constraints <- validate_type_minmax(column, sop_row$dataType, sop_row$minValue, sop_row$maxValue)
  
  # Initialize a variable for field-specific checks
  field_specific_check <- integer(0)  # Default to an empty vector
  
  # Combine all indices of invalid values from SOP and field-specific checks
  invalid_indices <- combine_unique_indices(SOP_constraints, field_specific_check)
  
  # Print the invalid indices and their corresponding values (if any issues)
  print_invalid_indices_and_values(column, field_name, invalid_indices)
}


```

-   Five issues have been found in parameter_name column. Some of them are in question format, that may need to be standerdaise.

-   There are 41 issues with the parameter_id column. They contain parts of description column, alongside of the parameter_id. For example, "housing_cage_dimensions_lxwxh, IMPC_HOU_076_001" should only be "IMPC_HOU_076_001"

-   There are some empty spaces in some parts of the dataset. For instance, some parts of the description column has no information.

```{r}

# Trim whitespaces and then replace blank strings with NA
metadata <- metadata %>%
  mutate(
    parameter_name = na_if(str_trim(parameter_name), ""),
    description = na_if(str_trim(description), ""),
  )
```

Removing any unwanted texts from the parameter_id column, only keeping the unique id starting with "IMPC\_"

```{r}

# Keep only the part of the string starting with "IMPC_" in the 'parameter_id' column
metadata <- metadata %>%
  mutate(
    parameter_id = str_extract(parameter_id, "IMPC_[^,]*") # Capture IMPC_ part and everything until the next comma or end of string
  )

```

Does the parameter_name needs to be standardised?

The problematic areas the script found: \[1\] " Difference in Conditioning Post-shock and Conditioning Baseline % Freezing"\
\[2\] " Nutrition - do you know the composition of the diet (average based on mass)"\
\[3\] " Nutrition - do you know the composition of the diet (average based on calorific content)" \[4\] " Nutrition - average composition (based on calorific content) - Carbohydrate"\
\[5\] " Microbiological status - is your unit positive for any of the pathogens tested"

```{r}

# Define the output path for the cleaned metadata
output_file_path <- paste0(rootDir, "data/cleaned/cleaned_IMPC_parameter_description.csv")

# Save the cleaned metadata as a CSV file
write.csv(metadata, file = output_file_path, row.names = FALSE)

# Completion message
cat("Cleaned metadata has been saved to:", output_file_path, "\n")

```
